twentyfiveseventy aka snmpv3

This service implements the very basics of an SNMPv3 agent.  It supports authentication and encryption but only for SNMP GET requests.  It follows the standard SNMP packet format.  The goal of the service is to figure out a way to bypass authentication, figure out the encryption passphrase and perform an SNMP GET of the OID (1.3.6.1.2.1.1.5.0) which contains the flag.

At the start of the program, the authentication passphrase is read from a file (auth_passphrase) in the service home directory and the flag is read from a file (flag) in that same directory.  The PRNG is seeded with time() and that same time value is used for the SNMPv3 variable myAuthoritativeEngineTime which is provided through an SNMP Discovery request.  The privacy/encryption passphrase is then generated as a 32-byte string of random printable characters.

SNMPv3 authentication is accomplished through a keyed MD5 hash over the entire SNMP message.  Normally, the first 12 bytes of this hash is used for authentication.  However, a bug exists in the service which allows the teams to specify the number of compared bytes for any lengths between 1 and 12.  If set to a length of 1, it's a relatively straight-forward and short brute-force exercise to find an HMAC which will satisfy the authentication requirements.  Testing has shown that between 100 and 200 SNMP GET requests are required to match the HMAC.  However, it should be noted that since several pieces of information in the packets are based on the initial PRNG seed, whatever passphrase the teams find that happens to match the target HMAC, will only work for that one TCP connection.  The service allows up to 255 failures before exiting.

SNMPv3 encryption is accomplished using DES.  The 32-byte passphrase randomly generated when the service starts is used indirectly as the key for the encryption and decryption.  However, since the PRNG is seeded with time and that time is leaked in the unencrypted portions of the SNMP PDU, it is quite easy for the teams to run their own PRNG seeded using the time they see in the PDU and re-generate the 32-byte passphrase.

With the authentication bypassed and the encryption passphrase calculated, the teams need to determine the SNMP OID which should be queried to obtain the flag.  That OID is stored in the binary and should be fairly straight-forward to identify since it's initialized in the same function where the flag is read. 
